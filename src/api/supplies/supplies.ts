/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * Conluz API
 * Conluz is an API-driven application designed for the efficient management of an energy community,enabling the administration of community members and their corresponding supply points and the retrieval of consumption, production data.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateSharingAgreementBody,
  CreateSuppliesWithFileBody,
  CreateSupplyBody,
  CreationInBulkResponse,
  GetAllSuppliesParams,
  ImportSuppliesPartitionsWithFileBody,
  ImportSuppliesPartitionsWithFileParams,
  PagedResultSupplyResponse,
  SharingAgreementResponse,
  SupplyResponse,
  UpdateSharingAgreementBody,
  UpdateSupplyBody
} from '.././models';

import { customInstance } from '.././custom-instance';
import type { ErrorType } from '.././custom-instance';




/**
 * This endpoint retrieves a supply by its unique identifier.
 * @summary Gets a supply by ID
 */
export const getSupply = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SupplyResponse>(
      {url: `/api/v1/supplies/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSupplyQueryKey = (id: string,) => {
    return [`/api/v1/supplies/${id}`] as const;
    }

    
export const getGetSupplyQueryOptions = <TData = Awaited<ReturnType<typeof getSupply>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupplyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupply>>> = ({ signal }) => getSupply(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSupplyQueryResult = NonNullable<Awaited<ReturnType<typeof getSupply>>>
export type GetSupplyQueryError = ErrorType<unknown>


export function useGetSupply<TData = Awaited<ReturnType<typeof getSupply>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSupply>>,
          TError,
          Awaited<ReturnType<typeof getSupply>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSupply<TData = Awaited<ReturnType<typeof getSupply>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSupply>>,
          TError,
          Awaited<ReturnType<typeof getSupply>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSupply<TData = Awaited<ReturnType<typeof getSupply>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Gets a supply by ID
 */

export function useGetSupply<TData = Awaited<ReturnType<typeof getSupply>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupply>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSupplyQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint enables the update of supply information by specifying the supply's unique identifier in the endpoint path.

Clients send a request containing the updated supply details, and authentication, through an authentication token, is required for secure access.

A successful update results in an HTTP status code of 200, indicating that the supply information has been successfully modified. In cases where the update encounters errors, the server responds with an appropriate error status code along with a descriptive error message to assist clients in addressing and resolving the issue.

If you don't provide some of the optional parameters, they will be considered as null value so their values will be updated with a null value.
 * @summary Updates supply information
 */
export const updateSupply = (
    id: string,
    updateSupplyBody: UpdateSupplyBody,
 ) => {
      
      
      return customInstance<SupplyResponse>(
      {url: `/api/v1/supplies/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSupplyBody
    },
      );
    }
  


export const getUpdateSupplyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext> => {

const mutationKey = ['updateSupply'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSupply>>, {id: string;data: UpdateSupplyBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSupply(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof updateSupply>>>
    export type UpdateSupplyMutationBody = UpdateSupplyBody
    export type UpdateSupplyMutationError = ErrorType<unknown>

    /**
 * @summary Updates supply information
 */
export const useUpdateSupply = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSupply>>,
        TError,
        {id: string;data: UpdateSupplyBody},
        TContext
      > => {

      const mutationOptions = getUpdateSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint retrieves a sharing agreement by its unique identifier.
 * @summary Gets a sharing agreement by ID
 */
export const getSharingAgreement = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SharingAgreementResponse>(
      {url: `/api/v1/sharing-agreements/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSharingAgreementQueryKey = (id: string,) => {
    return [`/api/v1/sharing-agreements/${id}`] as const;
    }

    
export const getGetSharingAgreementQueryOptions = <TData = Awaited<ReturnType<typeof getSharingAgreement>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSharingAgreementQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSharingAgreement>>> = ({ signal }) => getSharingAgreement(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSharingAgreementQueryResult = NonNullable<Awaited<ReturnType<typeof getSharingAgreement>>>
export type GetSharingAgreementQueryError = ErrorType<unknown>


export function useGetSharingAgreement<TData = Awaited<ReturnType<typeof getSharingAgreement>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharingAgreement>>,
          TError,
          Awaited<ReturnType<typeof getSharingAgreement>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSharingAgreement<TData = Awaited<ReturnType<typeof getSharingAgreement>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharingAgreement>>,
          TError,
          Awaited<ReturnType<typeof getSharingAgreement>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSharingAgreement<TData = Awaited<ReturnType<typeof getSharingAgreement>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Gets a sharing agreement by ID
 */

export function useGetSharingAgreement<TData = Awaited<ReturnType<typeof getSharingAgreement>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharingAgreement>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSharingAgreementQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint enables the update of sharing agreement information by specifying the agreement's unique
identifier in the endpoint path.

Clients send a request containing the updated agreement details, and authentication, through an
authentication token, is required for secure access.
**Required Role: ADMIN**

A successful update results in an HTTP status code of 200, indicating that the sharing agreement
information has been successfully modified and returning the updated agreement details.

In cases where the update encounters errors, the server responds with an appropriate error status
code, along with a descriptive error message to guide clients in addressing and resolving the issue.

If you don't provide some of the optional parameters, they will be considered as null value so their
values will be updated with a null value.

 * @summary Updates a sharing agreement
 */
export const updateSharingAgreement = (
    id: string,
    updateSharingAgreementBody: UpdateSharingAgreementBody,
 ) => {
      
      
      return customInstance<SharingAgreementResponse>(
      {url: `/api/v1/sharing-agreements/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSharingAgreementBody
    },
      );
    }
  


export const getUpdateSharingAgreementMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSharingAgreement>>, TError,{id: string;data: UpdateSharingAgreementBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSharingAgreement>>, TError,{id: string;data: UpdateSharingAgreementBody}, TContext> => {

const mutationKey = ['updateSharingAgreement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSharingAgreement>>, {id: string;data: UpdateSharingAgreementBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSharingAgreement(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSharingAgreementMutationResult = NonNullable<Awaited<ReturnType<typeof updateSharingAgreement>>>
    export type UpdateSharingAgreementMutationBody = UpdateSharingAgreementBody
    export type UpdateSharingAgreementMutationError = ErrorType<unknown>

    /**
 * @summary Updates a sharing agreement
 */
export const useUpdateSharingAgreement = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSharingAgreement>>, TError,{id: string;data: UpdateSharingAgreementBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSharingAgreement>>,
        TError,
        {id: string;data: UpdateSharingAgreementBody},
        TContext
      > => {

      const mutationOptions = getUpdateSharingAgreementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint enables the removal of a sharing agreement from the system by specifying the agreement's
unique identifier within the endpoint path.

To utilize this endpoint, clients send a DELETE request with the targeted agreement's ID, requiring
authentication for secure access.
**Required Role: ADMIN**

Upon successful deletion, the server responds with an HTTP status code of 200, indicating that the
sharing agreement has been successfully removed.

In cases where the deletion process encounters errors, the server returns an appropriate error
status code, along with a descriptive error message to guide clients in diagnosing and addressing
the issue.

 * @summary Removes a sharing agreement by ID
 */
export const deleteSharingAgreement = (
    id: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/sharing-agreements/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSharingAgreementMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSharingAgreement>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSharingAgreement>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteSharingAgreement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSharingAgreement>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteSharingAgreement(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSharingAgreementMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSharingAgreement>>>
    
    export type DeleteSharingAgreementMutationError = ErrorType<unknown>

    /**
 * @summary Removes a sharing agreement by ID
 */
export const useDeleteSharingAgreement = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSharingAgreement>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSharingAgreement>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteSharingAgreementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint serves to retrieve all registered supplies within the system, supporting pagination, filtering, and sorting for a customized query experience. This endpoint requires authentication through a Bearer Token for secure access. Clients can include optional query parameters such as page to specify the page number, limit to determine supplies per page, filter to selectively retrieve supplies based on criteria, and sort to define the order of the results. A successful request yields a paginated list of supplies, providing essential details, while any authentication or retrieval issues prompt an appropriate error response. With its versatile functionality, this endpoint enhances the ability to explore and manage the array of energy supplies within the system.
 * @summary Retrieves all registered supplies in the system with support for pagination, filtering, and sorting.
 */
export const getAllSupplies = (
    params?: GetAllSuppliesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PagedResultSupplyResponse>(
      {url: `/api/v1/supplies`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAllSuppliesQueryKey = (params?: GetAllSuppliesParams,) => {
    return [`/api/v1/supplies`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllSuppliesQueryOptions = <TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = ErrorType<unknown>>(params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllSuppliesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllSupplies>>> = ({ signal }) => getAllSupplies(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllSuppliesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllSupplies>>>
export type GetAllSuppliesQueryError = ErrorType<unknown>


export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = ErrorType<unknown>>(
 params: undefined |  GetAllSuppliesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllSupplies>>,
          TError,
          Awaited<ReturnType<typeof getAllSupplies>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = ErrorType<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllSupplies>>,
          TError,
          Awaited<ReturnType<typeof getAllSupplies>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = ErrorType<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves all registered supplies in the system with support for pagination, filtering, and sorting.
 */

export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = ErrorType<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllSuppliesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint is designed to create a new supply within the system.

To utilize this endpoint, a client sends a request containing essential details such as the supply's address, partition coefficient, and any relevant parameters.

Proper authentication, through authentication tokens, is required to access this endpoint.
**Required Role: ADMIN**

Upon successful creation, the server responds with a status code of 200, providing comprehensive details about the newly created supply, including its unique identifier.

In case of failure, the server returns an appropriate error status code along with a descriptive error message, aiding the client in diagnosing and addressing the issue. This endpoint plays a pivotal role in dynamically expanding the system's repertoire of energy supplies.

 * @summary Creates a new supply within the system.
 */
export const createSupply = (
    createSupplyBody: CreateSupplyBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SupplyResponse>(
      {url: `/api/v1/supplies`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSupplyBody, signal
    },
      );
    }
  


export const getCreateSupplyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext> => {

const mutationKey = ['createSupply'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupply>>, {data: CreateSupplyBody}> = (props) => {
          const {data} = props ?? {};

          return  createSupply(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof createSupply>>>
    export type CreateSupplyMutationBody = CreateSupplyBody
    export type CreateSupplyMutationError = ErrorType<unknown>

    /**
 * @summary Creates a new supply within the system.
 */
export const useCreateSupply = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSupply>>,
        TError,
        {data: CreateSupplyBody},
        TContext
      > => {

      const mutationOptions = getCreateSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint enables a supply by its unique identifier.

Authentication via bearer token is required.
Required Role: ADMIN

The operation is idempotent: enabling an already enabled supply will not fail and will return the current state.

 * @summary Enables a supply by ID
 */
export const enableSupply = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SupplyResponse>(
      {url: `/api/v1/supplies/${id}/enable`, method: 'POST', signal
    },
      );
    }
  


export const getEnableSupplyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableSupply>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enableSupply>>, TError,{id: string}, TContext> => {

const mutationKey = ['enableSupply'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableSupply>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  enableSupply(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnableSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof enableSupply>>>
    
    export type EnableSupplyMutationError = ErrorType<unknown>

    /**
 * @summary Enables a supply by ID
 */
export const useEnableSupply = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableSupply>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enableSupply>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getEnableSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint disables a supply by its unique identifier.

Authentication via bearer token is required.
Required Role: ADMIN

The operation is idempotent: disabling an already disabled supply will not fail and will return the current state.

 * @summary Disables a supply by ID
 */
export const disableSupply = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SupplyResponse>(
      {url: `/api/v1/supplies/${id}/disable`, method: 'POST', signal
    },
      );
    }
  


export const getDisableSupplyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableSupply>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disableSupply>>, TError,{id: string}, TContext> => {

const mutationKey = ['disableSupply'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableSupply>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  disableSupply(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof disableSupply>>>
    
    export type DisableSupplyMutationError = ErrorType<unknown>

    /**
 * @summary Disables a supply by ID
 */
export const useDisableSupply = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableSupply>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableSupply>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDisableSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint facilitates the creation of a set of supplies partitions within the system by
importing a CSV file.

This endpoint requires clients to send a request containing a file with an identifier and the
coefficient for each supply.

Authentication is mandated, utilizing an authentication token, to ensure secure access.
**Required Role: ADMIN**

Upon successful file processing, the server responds with an HTTP status code of 200, along with
comprehensive details about the result of the bulk operation, including what supplies partitions
have been created or any potential error.

In cases where the creation process encounters errors, the server responds with an appropriate error
status code, accompanied by a descriptive error message to guide clients in addressing and resolving
the issue.

 * @summary Creates supplies partitions in bulk importing a CSV file.
 */
export const importSuppliesPartitionsWithFile = (
    importSuppliesPartitionsWithFileBody: ImportSuppliesPartitionsWithFileBody,
    params: ImportSuppliesPartitionsWithFileParams,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, importSuppliesPartitionsWithFileBody.file)

      return customInstance<CreationInBulkResponse>(
      {url: `/api/v1/supplies/partitions/import`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      );
    }
  


export const getImportSuppliesPartitionsWithFileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>, TError,{data: ImportSuppliesPartitionsWithFileBody;params: ImportSuppliesPartitionsWithFileParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>, TError,{data: ImportSuppliesPartitionsWithFileBody;params: ImportSuppliesPartitionsWithFileParams}, TContext> => {

const mutationKey = ['importSuppliesPartitionsWithFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>, {data: ImportSuppliesPartitionsWithFileBody;params: ImportSuppliesPartitionsWithFileParams}> = (props) => {
          const {data,params} = props ?? {};

          return  importSuppliesPartitionsWithFile(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImportSuppliesPartitionsWithFileMutationResult = NonNullable<Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>>
    export type ImportSuppliesPartitionsWithFileMutationBody = ImportSuppliesPartitionsWithFileBody
    export type ImportSuppliesPartitionsWithFileMutationError = ErrorType<unknown>

    /**
 * @summary Creates supplies partitions in bulk importing a CSV file.
 */
export const useImportSuppliesPartitionsWithFile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>, TError,{data: ImportSuppliesPartitionsWithFileBody;params: ImportSuppliesPartitionsWithFileParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof importSuppliesPartitionsWithFile>>,
        TError,
        {data: ImportSuppliesPartitionsWithFileBody;params: ImportSuppliesPartitionsWithFileParams},
        TContext
      > => {

      const mutationOptions = getImportSuppliesPartitionsWithFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint facilitates the creation of a set of supplies within the system by importing a
CSV file.

This endpoint requires clients to send a request containing a file with essential details for each
supply, including code, address, users and any additional relevant information.

Authentication is mandated, utilizing an authentication token, to ensure secure access.
**Required Role: ADMIN**

Upon successful file processing, the server responds with an HTTP status code of 200, along with
comprehensive details about the result of the bulk operation, including what users have been created
or any potential error.

In cases where the creation process encounters errors, the server responds with an appropriate error status code, accompanied by a descriptive error message to guide clients in addressing and resolving the issue.

 * @summary Creates supplies in bulk importing a CSV file.
 */
export const createSuppliesWithFile = (
    createSuppliesWithFileBody: CreateSuppliesWithFileBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, createSuppliesWithFileBody.file)

      return customInstance<CreationInBulkResponse>(
      {url: `/api/v1/supplies/import`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreateSuppliesWithFileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext> => {

const mutationKey = ['createSuppliesWithFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSuppliesWithFile>>, {data: CreateSuppliesWithFileBody}> = (props) => {
          const {data} = props ?? {};

          return  createSuppliesWithFile(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSuppliesWithFileMutationResult = NonNullable<Awaited<ReturnType<typeof createSuppliesWithFile>>>
    export type CreateSuppliesWithFileMutationBody = CreateSuppliesWithFileBody
    export type CreateSuppliesWithFileMutationError = ErrorType<unknown>

    /**
 * @summary Creates supplies in bulk importing a CSV file.
 */
export const useCreateSuppliesWithFile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSuppliesWithFile>>,
        TError,
        {data: CreateSuppliesWithFileBody},
        TContext
      > => {

      const mutationOptions = getCreateSuppliesWithFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint enables users to synchronize all active supplies retrieving the information from
datadis.es.

Proper authentication, through an authentication token, is required for secure access to this
endpoint.
**Required Role: ADMIN**

A successful request returns an HTTP status code of 200.

In cases of errors, the server responds with an appropriate error status code accompanied by a
descriptive message to guide users in resolving any issues.

 * @summary Synchronize supplies retrieving the information from datadis.es.
 */
export const syncDatadisSupplies = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/supplies/datadis/sync`, method: 'POST', signal
    },
      );
    }
  


export const getSyncDatadisSuppliesMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext> => {

const mutationKey = ['syncDatadisSupplies'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncDatadisSupplies>>, void> = () => {
          

          return  syncDatadisSupplies()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncDatadisSuppliesMutationResult = NonNullable<Awaited<ReturnType<typeof syncDatadisSupplies>>>
    
    export type SyncDatadisSuppliesMutationError = ErrorType<unknown>

    /**
 * @summary Synchronize supplies retrieving the information from datadis.es.
 */
export const useSyncDatadisSupplies = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncDatadisSupplies>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSyncDatadisSuppliesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint creates a new sharing agreement with the specified start and end dates.
 * @summary This endpoint facilitates the creation of a new sharing agreement within the system.

To utilize this endpoint, clients send a request containing essential details such as the agreement's
start and end dates.

Authentication is mandated, utilizing an authentication token, to ensure secure access.
**Required Role: ADMIN**

Upon successful creation, the server responds with an HTTP status code of 200, providing comprehensive
details about the newly created sharing agreement.

In cases where the creation process encounters errors, the server responds with an appropriate error
status code, accompanied by a descriptive error message to guide clients in addressing and resolving
the issue.

 */
export const createSharingAgreement = (
    createSharingAgreementBody: CreateSharingAgreementBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SharingAgreementResponse>(
      {url: `/api/v1/sharing-agreements`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSharingAgreementBody, signal
    },
      );
    }
  


export const getCreateSharingAgreementMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSharingAgreement>>, TError,{data: CreateSharingAgreementBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSharingAgreement>>, TError,{data: CreateSharingAgreementBody}, TContext> => {

const mutationKey = ['createSharingAgreement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSharingAgreement>>, {data: CreateSharingAgreementBody}> = (props) => {
          const {data} = props ?? {};

          return  createSharingAgreement(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSharingAgreementMutationResult = NonNullable<Awaited<ReturnType<typeof createSharingAgreement>>>
    export type CreateSharingAgreementMutationBody = CreateSharingAgreementBody
    export type CreateSharingAgreementMutationError = ErrorType<unknown>

    /**
 * @summary This endpoint facilitates the creation of a new sharing agreement within the system.

To utilize this endpoint, clients send a request containing essential details such as the agreement's
start and end dates.

Authentication is mandated, utilizing an authentication token, to ensure secure access.
**Required Role: ADMIN**

Upon successful creation, the server responds with an HTTP status code of 200, providing comprehensive
details about the newly created sharing agreement.

In cases where the creation process encounters errors, the server responds with an appropriate error
status code, accompanied by a descriptive error message to guide clients in addressing and resolving
the issue.

 */
export const useCreateSharingAgreement = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSharingAgreement>>, TError,{data: CreateSharingAgreementBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSharingAgreement>>,
        TError,
        {data: CreateSharingAgreementBody},
        TContext
      > => {

      const mutationOptions = getCreateSharingAgreementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    